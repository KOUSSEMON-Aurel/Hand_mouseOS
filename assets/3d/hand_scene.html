<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hand Mouse 3D HUD</title>
    <style>
        body { margin: 0; background: #0b0c10; overflow: hidden; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #hud {
            position: absolute; top: 10px; left: 10px; color: #66fcf1;
            font-size: 10px; pointer-events: none; text-shadow: 0 0 5px #45a29e;
        }
    </style>
</head>
<body>
    <div id="hud">SYSTEM_3D_RENDER: ACTIVE<br>CORE: RUST_ACCELERATED<br>LINK: STABLE</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0x66fcf1, 1, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        // Grid
        const gridHelper = new THREE.GridHelper(20, 20, 0x45a29e, 0x1f2833);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.z = -5;
        scene.add(gridHelper);

        // Hand Model - 21 Joints
        const joints = [];
        const jointMaterial = new THREE.MeshPhongMaterial({ color: 0x66fcf1, emissive: 0x45a29e });
        const jointGeometry = new THREE.SphereGeometry(0.15, 12, 12);

        for (let i = 0; i < 21; i++) {
            const sphere = new THREE.Mesh(jointGeometry, jointMaterial);
            scene.add(sphere);
            joints.push(sphere);
        }

        // Bones - Connecting Joints
        const connections = [
            [0,1,2,3,4], [0,5,6,7,8], [5,9,13,17], [0,17,18,19,20],
            [9,10,11,12], [13,14,15,16]
        ];
        
        const boneMaterial = new THREE.LineBasicMaterial({ color: 0x45a29e, transparent: true, opacity: 0.6 });
        const bones = [];

        function createBones() {
            // MediaPipe connections
            const pairs = [
                [0,1],[1,2],[2,3],[3,4], // Thumb
                [0,5],[5,6],[6,7],[7,8], // Index
                [5,9],[9,10],[10,11],[11,12], // Middle
                [9,13],[13,14],[14,15],[15,16], // Ring
                [13,17],[17,18],[18,19],[19,20],[0,17] // Pinky + Palm base
            ];

            pairs.forEach(p => {
                const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
                const line = new THREE.Line(geometry, boneMaterial);
                scene.add(line);
                bones.push({ line, p });
            });
        }
        createBones();

        camera.position.z = 10;

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Data Interface
        window.addEventListener('message', (event) => {
            const landmarks = event.data;
            if (!landmarks || landmarks.length !== 21) return;

            // Update Joints
            landmarks.forEach((lm, i) => {
                // Normalize and scale (MediaPipe is 0-1, 3D space is different)
                // We center 0.5, 0.5 to 0, 0 and scale by 10
                const x = (lm.x - 0.5) * 15;
                const y = -(lm.y - 0.5) * 15; 
                const z = -lm.z * 15; // Z for depth

                joints[i].position.set(x, y, z);
            });

            // Update Bones
            bones.forEach(b => {
                const p1 = joints[b.p[0]].position;
                const p2 = joints[b.p[1]].position;
                b.line.geometry.setFromPoints([p1, p2]);
            });
        });

        // Debug mode for local testing
        window.updateHand = function(data) {
             window.dispatchEvent(new MessageEvent('message', {data: data}));
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
